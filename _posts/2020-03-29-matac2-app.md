---
layout: post
title:  "Как написать настольное приложение в условиях нечетких и изменчивых требований"
date:   2020-03-29 11:30:00 +0300
categories: apps exp
preview: /assets/img/posts/matac2/preview.png
---
Хочу поделиться опытом, полученным мною за последние три месяца и рассказать, как 
я написал настольное приложение для ведения учета в условиях недостатка времени, 
часто изменяющейся структуры данных, необходимости постоянного расширения 
функционала и добавления новых шаблонов генерируемых отчетов.
 
TL;DR: Как написать? 
1. Оценка требований (отсутствие четких требований 
тоже требование). 
2. Подбор инструментов и подходов к решению. Неукоснительное соблюдение [DRY][dry].
3. Максимальная автоматизация изменения приложения при изменение схемы данных. 
4. Ведение инструкции по изменению отдельных компонентов при изменении требований.<!--more-->
5. Рефакторинг на основе п.4 ради п.3. 


## Немного из биографии
Так уж сложилось, что мой программистский путь шел почти исключительно 
через создание портативных настольных приложений, содержащих в себе всю 
нужную для работы логику. 
Только первое, в 2010 году, было частью другого, более крупного, но выражалось 
это в том, что вместо `JFrame` у меня был `JPanel` (пять лет писал на **Swing**, 
потом переключился на **JavaFX**, что можно увидеть в 
[проектах]({% link projects.md %})) да подключение к базе я получал из чужого 
класса. А еще за последний год в рамках изучения технологий, написал 
небольшое (пока) [веб-приложение][h168].

В середине прошлого года решил я попробовать **Kotlin**, и чтобы два раза не ходить, 
заодно посмотреть, что сейчас в мире мобильной разработки под **Android**. В связи с 
чем и записался на удачно подвернувшийся бесплатный интенсив по Android-разработке 
на Kotlin. К сожалению, так как курс был хороший и бесплатный, новые занятия 
появлялись медленнее, чем планировалось авторами, а потому где-то в середине 
я переключился на подготовку к сдаче **OCA**, да и на работе нагрузка увеличилась. 
Но Kotlin мне понравился.

> Подсказка: чтобы что-то удачно подвернулось, нужно иметь запас вещей, которые 
> хотите изучать; потом мне так же удачно подвернулся курс по разработке на Scala, 
> о чем как-нибудь в другой раз.

## Насущная необходимость
К концу года назрела необходимость существенно обновить свою программу для ведения 
материального учета. Подумав некоторое время, я решил, что писать на связке 
**Kotlin** + **JavaFX** + **Hibernate** будет быстрее, а потому набросал 
примерную схему базы данных и приступил к написанию основы логики взаимодействия 
с БД, параллельно посматривая в сторону каких-нибудь интерфейсных библиотек для 
JavaFX (помимо **ControlsFX**). Наткнулся на [**TornadoFX**][tfx] — написанный 
на Kotlin фреймворк, позволяющий лаконично писать интерфейс (в том числе 
описывать CSS) в DSL-стиле. Бонусом шла реализация функционала внедрения 
зависимостей. Отметил в уме и продолжил поиски. 

## Обдумывание и наступление
С января перешел в активную фазу написания приложения на следующем стеке: 

> Kotlin + Hibernate + [H2 Database][h2] + 
>
> JavaFX + [TornadoFX][tfx] + [ControlsFX][cfx] + 
>
> [Kotlin XML Builder][xml] + [Apache POI][poi] + [Xylophone][xyl].
 
[Последний][xyl] взял попробовать; возникли проблемы с использованием, но я нашел, 
как их обойти без серьезного изучения и переписывания иcходников).
Перед написанием кода, на этапе окончательного выбора стека, выделил следующие 
ключевые моменты, которые нужно было учесть:
0.  Нужна переносимость приложения.
1.	База данных может неоднократно и существенно изменяться.
2.	Данных будет не слишком много (скорее всего, меньше сотни тысяч записей 
по всем таблицам за несколько лет).
3.	Необходимо минимизировать количество кода, который нужно написать для 
добавления новых шаблонов документов.
4.	Нужна возможность выгружать данные прямо из таблиц в интерфейсе.
5.	Интерфейс и выгрузка данных должны максимально автоматизировано подхватывать 
изменения в схеме данных.

В результате для шаблонов выбрал Xylophone, автоматическую подстройку реализовал 
активным использованием Reflection API. Вот решения по пунктам:
0.  База данных H2.
1.	Миграции путем полной выгрузки данных в Excel, удалении базы и загрузки 
обратно (бонусом идет, собственно, выгрузка в Excel и возможность редактировать 
имеющиеся поля и добавлять новые). Reflection API + Apache POI.
2.	H2 и решение из предыдущего пункта.
3.	Xylophone + Kotlin XML Builder.
4.	Reflection API + Apache POI.
5.	Reflection API.

Классы модели данных реализовал как data-классы Kotlin, все поля через reflection 
отлично подтягиваются из конструктора, еще и в порядке определения. По типу 
переменной в конструкторе data-класса в своем конструкторе форм определяю, 
какой интерфейсный элемент использовать, в конвертере (для загрузки/выгрузки) — 
как преобразовать в строку и обратно, при работе с базой данных — какой DAO 
использовать для общих операций. 

## Жонглирование данными
При загрузке-выгрузке дампа в Excel (можно и в csv было, но это уже вкусовщина) 
все внешние ссылки заменяются на ID объекта в базе, при загрузке обратно объекты 
и ссылки обновляются, если была запись с таким ID, либо запись сохраняется как 
новая. Достигается это все загрузкой всего графа объектов в память с последующим 
сохранением/обновлением. Понятно, что возможны проблемы при таком подходе, 
если менять многое вручную одновременно в программе и дампе, а затем загрузить, 
но для таких случаев эта функциональность и не предназначена. Зато получаются 
простые миграции. Для не сильно большого числа записей в базе и частого изменения 
структуры БД это оказался удобный подход. Еще одним плюсом является возможность 
использования преимуществ Excel при массовом редактировании и добавлении записей.

Шаблоны считываются из папки, при этом каждый шаблон лежит в своей подпапке, 
название которой и становится названием шаблона в интерфейсе. Подготовка 
заключается в написании xml-дескриптора с порядком заполнения шаблона, 
создании самого Excel-шаблона с переменными (см. [документацию Xylophone][xyl-doc]), 
написании класса, наследующего от базового, в котором нужно реализовать 
только метод создания xml с данными (тут пригождается Kotlin XML Builder). 
Нужный класс для генерации данных вызывается через reflection по названию 
файла дополнительных настроек в папке шаблона.

## Печать интерфейса
TornadoFX позволил быстро набросать интерфейс, при этом я взял оттуда паттерн 
написания методов для методов (в т.ч. расширений) создания интерфейсных элементов 
под свои нужды. Суть его в том, что в качестве последнего параметра передается 
лямбда, в которой описывается дополнительная настройка компонента. Это позволяет, 
помимо прочего, использовать синтаксический сахар в Kotlin с выносом тела 
лямбда-выражения за круглые скобки.

Всех фич TornadoFX я не использовал (например, Fragments), но и использованного 
хватило для быстрого создания рабочего приложения с хорошей функциональностью. 
Даже пару стилей набросал (светлый и темный). 
С помощью Reflection API и добавления настроечных аннотаций (например указания 
на нередактируемость в интерфейсе) для параметров классов сущностей написал 
автоматическую генерацию формы редактирования экземпляра сущности. 
Написал свою панель `SearchPane`, в которую вкладывается список `ListView` или 
таблица `TableView`, и которая позволяет производить поиск (фильтрацию) 
по значению полей экземпляров сущностей (да-да, через reflection). Можно 
даже использовать регулярные выражения.

<div class="centered"></div>

![][search]
> Поиск в SearchPane

Повсеместное использование Reflection API и общая генерализация 
форм представления позволили не думать про редактирование интерфейса при добавлении 
новой сущности или изменении старой. Например, для нового поля уже обрабатываемого 
типа данных необходимо добавить:

1.	Поле в data-класс сущности.
2.	Поле в интерфейсное представление (ItemViewModel из TornadoFX, 
использует property-поля JavaFX, привязывая к полям 'обычного' бина).
3.	Локализацию.

Все. 

<div class="centered"></div>

![][table-form]

<div class="centered"></div>

![][entry-doc] 
> Универсальная таблица и генерируемая для сущности форма редактора.

Для добавления нового класса шагов побольше. Нужно добавить:
1. Data-класс сущности.
2. Класс представления.
3. Локализацию.
4. DAO (одна строка наследования от базового класса + 
   дополнительные методы получения выборок данных)
5. Маппинг в hibernate.cfg.
6. Генерацию интерфейсных элементов.
7. Таблицы и дополнительные кнопки в интерфейс (если нужно), 
взаимодействие с имеющимися.
8. DAO и методы получения данных в контроллер.
9. Запись в специальном списке, если объект ссылается на себя. 
10. Обработку в строку и обратно в конвертер.

Часть шагов тоже можно автоматизировать, но пока до этого руки не дошли, 
не в приоритете, а инструкцию по добавлению я себе сделал. :) 

Весь процесс добавления (написание кода) занимает примерно двадцать минут. 
Кода получается немного. Вот, например, код одного дополнительного метода 
получения данных в одном DAO:
```kotlin
fun getEntriesOfSelectedSet(set: SelectedSet): List<Entry> =
    worker.getWithParamQuery<SelectedEntry>(
        "from SelectedEntry where selected_set_id=:id",
        QueryLang.HQL, mapOf<String,Any>( "id" to set.id )
    ).map { e -> e.entry }
``` 

## Итог
Полтора-два месяца разработки с параллельным выполнением основных 
обязанностей — рабочее приложение, которое несложно быстро расширять как с 
точки зрения хранимых данных, так и генерации шаблонов всевозможной 
документации и отчетов (что уже проверено). Недостатки универсального 
подхода тоже присутствуют (приходится иногда делать больше кликов, чем 
хотелось бы), но это решаемые проблемы даже при текущем подходе. 
В остальном полный успех.

[dry]:https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself
[h168]:https://github.com/Midest/168-Hours
[tfx]:https://github.com/edvin/tornadofx
[cfx]:https://github.com/controlsfx/controlsfx
[h2]:https://www.h2database.com/
[poi]:https://poi.apache.org/
[xyl]:https://github.com/CourseOrchestra/xylophone
[xml]:https://github.com/redundent/kotlin-xml-builder
[xyl-doc]:https://courseorchestra.github.io/xylophone/

[table-form]:/assets/img/posts/matac2/table-form.png
[entry-doc]:/assets/img/posts/matac2/entry-doc.png
[table]:/assets/img/posts/matac2/table.png
[search]:/assets/img/posts/matac2/search.png
